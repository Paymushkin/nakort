{"version":3,"file":"about-scroll.min.js","sources":["about-scroll.js"],"sourcesContent":["// Scroll-linked Animation для страницы About\n// Плавная смена 30 изображений при скролле\n\n(function() {\n  'use strict';\n\n  class AboutScrollAnimation {\n    constructor() {\n      this.canvas = null;\n      this.ctx = null;\n      this.container = null;\n      this.scrollSection = null;\n      this.loader = null;\n      \n      // Animation settings\n      this.totalFrames = 30; // Все 30 изображений\n      this.framePrefix = 'ezgif-frame-';\n      this.frameSuffix = '.jpg';\n      this.framesPath = 'img/frames/';\n      \n      // Image preloading\n      this.images = [];\n      this.loadedImages = 0;\n      this.isLoading = false;\n      this.isLoaded = false;\n      \n      // Scroll tracking\n      this.currentFrame = 0;\n      this.scrollProgress = 0;\n      this.ticking = false;\n      \n      // Canvas settings\n      this.dpr = window.devicePixelRatio || 1;\n      this.canvasWidth = 0;\n      this.canvasHeight = 0;\n      \n      this.init();\n    }\n\n    init() {\n      // Проверяем, что мы на странице About\n      this.scrollSection = document.querySelector('.about-scroll');\n      if (!this.scrollSection) return;\n\n      this.canvas = document.getElementById('scrollCanvas');\n      this.container = document.querySelector('.about-scroll__container');\n      this.loader = document.querySelector('.about-scroll__loader');\n      \n      if (!this.canvas || !this.container) return;\n\n      this.ctx = this.canvas.getContext('2d');\n      if (!this.ctx) return;\n\n      // Инициализируем canvas\n      this.setupCanvas();\n      \n      // Загружаем изображения\n      this.preloadImages();\n      \n      // Обработка ресайза\n      let resizeTimeout;\n      window.addEventListener('resize', () => {\n        clearTimeout(resizeTimeout);\n        resizeTimeout = setTimeout(() => {\n          this.setupCanvas();\n          if (this.isLoaded) {\n            this.drawFrame(this.currentFrame);\n          }\n        }, 250);\n      });\n    }\n\n    setupCanvas() {\n      if (!this.canvas || !this.container) return;\n\n      const width = window.innerWidth;\n      const height = window.innerHeight;\n\n      // Устанавливаем размеры canvas с учетом devicePixelRatio для четкости\n      this.canvasWidth = width;\n      this.canvasHeight = height;\n      \n      this.canvas.width = width * this.dpr;\n      this.canvas.height = height * this.dpr;\n      \n      // Масштабируем контекст для четкого рендеринга\n      this.ctx.scale(this.dpr, this.dpr);\n      \n      // Устанавливаем CSS размеры\n      this.canvas.style.width = width + 'px';\n      this.canvas.style.height = height + 'px';\n    }\n\n    // Preload всех изображений последовательности\n    async preloadImages() {\n      if (this.isLoading) return;\n      \n      this.isLoading = true;\n      this.loadedImages = 0;\n      this.images = [];\n\n      const loadPromises = [];\n\n      for (let i = 1; i <= this.totalFrames; i++) {\n        const frameNumber = String(i).padStart(3, '0');\n        const imagePath = `${this.framesPath}${this.framePrefix}${frameNumber}${this.frameSuffix}`;\n        \n        const promise = new Promise((resolve, reject) => {\n          const img = new Image();\n          \n          img.onload = () => {\n            this.loadedImages++;\n            this.updateLoaderProgress();\n            resolve(img);\n          };\n          \n          img.onerror = () => {\n            console.warn(`Failed to load frame: ${imagePath}`);\n            // Создаем пустое изображение в случае ошибки\n            const errorImg = new Image();\n            errorImg.width = 1920;\n            errorImg.height = 1080;\n            this.loadedImages++;\n            this.updateLoaderProgress();\n            resolve(errorImg);\n          };\n          \n          img.src = imagePath;\n        });\n\n        loadPromises.push(promise);\n      }\n\n      try {\n        this.images = await Promise.all(loadPromises);\n        this.isLoaded = true;\n        this.isLoading = false;\n        this.hideLoader();\n        this.startAnimation();\n      } catch (error) {\n        console.error('Error loading images:', error);\n        this.isLoading = false;\n        this.hideLoader();\n      }\n    }\n\n    updateLoaderProgress() {\n      if (!this.loader) return;\n      \n      const progress = Math.round((this.loadedImages / this.totalFrames) * 100);\n      const loaderText = this.loader.querySelector('.about-scroll__loader-text');\n      \n      if (loaderText) {\n        loaderText.textContent = `Загрузка... ${progress}%`;\n      }\n    }\n\n    hideLoader() {\n      if (!this.loader) return;\n      \n      setTimeout(() => {\n        this.loader.classList.add('about-scroll__loader--hidden');\n        \n        // Удаляем loader из DOM после анимации\n        setTimeout(() => {\n          if (this.loader.parentNode) {\n            this.loader.parentNode.removeChild(this.loader);\n          }\n        }, 500);\n      }, 300);\n    }\n\n    startAnimation() {\n      if (!this.isLoaded || !this.canvas || !this.ctx) return;\n\n      // Рисуем первый кадр\n      this.drawFrame(0);\n      \n      // Начинаем отслеживание скролла\n      window.addEventListener('scroll', () => this.onScroll(), { passive: true });\n      this.onScroll();\n    }\n\n    onScroll() {\n      if (!this.ticking) {\n        window.requestAnimationFrame(() => {\n          this.updateScrollProgress();\n          this.ticking = false;\n        });\n        this.ticking = true;\n      }\n    }\n\n    updateScrollProgress() {\n      if (!this.scrollSection || !this.container) return;\n\n      const scrollY = window.scrollY || window.pageYOffset;\n      const windowHeight = window.innerHeight;\n      const sectionTop = this.scrollSection.offsetTop;\n      const sectionHeight = this.scrollSection.offsetHeight;\n      \n      // Вычисляем прогресс скролла для sticky canvas\n      // Canvas sticky остается на месте пока секция прокручивается\n      // Анимация начинается когда верх секции достигает верха экрана\n      // Анимация заканчивается когда мы прошли всю высоту секции (300vh)\n      // После этого canvas \"отпускается\" и скролл продолжается\n      \n      // Начало анимации: когда верх секции достигает верха экрана\n      const scrollStart = sectionTop;\n      // Конец анимации: когда мы прошли всю высоту секции\n      // Учитываем, что sticky элемент остается на месте пока секция прокручивается\n      const scrollEnd = sectionTop + sectionHeight - windowHeight;\n      const scrollRange = scrollEnd - scrollStart;\n      \n      // Прогресс скролла от 0 до 1 в пределах секции\n      let progress = 0;\n      if (scrollY < scrollStart) {\n        // Еще не дошли до секции - показываем первый кадр\n        progress = 0;\n      } else if (scrollY >= scrollEnd) {\n        // Прошли всю секцию - показываем последний кадр\n        progress = 1;\n      } else {\n        // Внутри секции - вычисляем прогресс от 0 до 1\n        progress = (scrollY - scrollStart) / scrollRange;\n      }\n      \n      this.scrollProgress = progress;\n      \n      // Вычисляем текущий кадр (0 to totalFrames - 1)\n      // Плавно переходим от первого к последнему изображению через все 30 кадров\n      const frameIndex = Math.round(progress * (this.totalFrames - 1));\n      this.currentFrame = Math.max(0, Math.min(this.totalFrames - 1, frameIndex));\n      \n      // Рисуем текущий кадр\n      if (this.isLoaded && this.images[this.currentFrame]) {\n        this.drawFrame(this.currentFrame);\n      }\n    }\n\n    drawFrame(frameIndex) {\n      if (!this.ctx || !this.canvas || !this.images[frameIndex]) return;\n\n      const img = this.images[frameIndex];\n      \n      // Очищаем canvas\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      \n      // Вычисляем размеры изображения для правильного масштабирования (contain fit)\n      const imgAspect = img.width / img.height;\n      const canvasAspect = this.canvasWidth / this.canvasHeight;\n      \n      let drawWidth = this.canvasWidth;\n      let drawHeight = this.canvasHeight;\n      let drawX = 0;\n      let drawY = 0;\n      \n      if (imgAspect > canvasAspect) {\n        // Изображение шире - подгоняем по ширине\n        drawHeight = this.canvasWidth / imgAspect;\n        drawY = (this.canvasHeight - drawHeight) / 2;\n      } else {\n        // Изображение выше - подгоняем по высоте\n        drawWidth = this.canvasHeight * imgAspect;\n        drawX = (this.canvasWidth - drawWidth) / 2;\n      }\n      \n      // Рисуем изображение\n      this.ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n    }\n  }\n\n  // Инициализация при загрузке DOM\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      new AboutScrollAnimation();\n    });\n  } else {\n    new AboutScrollAnimation();\n  }\n})();\n"],"names":["AboutScrollAnimation","constructor","this","canvas","ctx","container","scrollSection","loader","totalFrames","framePrefix","frameSuffix","framesPath","images","loadedImages","isLoading","isLoaded","currentFrame","scrollProgress","ticking","dpr","window","devicePixelRatio","canvasWidth","canvasHeight","init","document","querySelector","getElementById","getContext","setupCanvas","preloadImages","let","resizeTimeout","addEventListener","clearTimeout","setTimeout","drawFrame","width","height","innerWidth","innerHeight","scale","style","loadPromises","i","frameNumber","String","padStart","imagePath","promise","Promise","resolve","reject","img","Image","onload","updateLoaderProgress","onerror","console","warn","errorImg","src","push","await","all","hideLoader","startAnimation","error","progress","loaderText","Math","round","textContent","classList","add","parentNode","removeChild","onScroll","passive","requestAnimationFrame","updateScrollProgress","scrollY","pageYOffset","sectionTop","offsetTop","scrollEnd","offsetHeight","frameIndex","max","min","imgAspect","clearRect","canvasAspect","drawWidth","drawHeight","drawX","drawY","drawImage","readyState"],"mappings":"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"}